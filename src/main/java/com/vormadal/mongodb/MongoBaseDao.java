package com.vormadal.mongodb;

import com.mongodb.WriteResult;
import com.vormadal.mongodb.exceptions.MorphiaException;
import com.vormadal.mongodb.models.HasId;
import com.vormadal.mongodb.models.ListWithTotal;
import com.vormadal.mongodb.models.Order;
import com.vormadal.mongodb.options.DaoOptions;
import xyz.morphia.Datastore;
import xyz.morphia.aggregation.AggregationPipeline;
import xyz.morphia.query.*;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Created: 21-09-2018
 * author: Runi
 */
public abstract class MongoBaseDao<T extends HasId<I>, I> implements BaseDao<T, I> {

    protected Class<T> type;
    private DbProvider provider;

    private final String wildcardChar;

    private final boolean fetchUpdatedElement;

    public MongoBaseDao(DbProvider provider, Class<T> type) {
        this(provider, type, false);
    }

    /**
     *
     * @param provider
     * @param type
     * @param fetchUpdatedElement - if true, when making partial updates the method will fetch the
     *                            element from the database ensuring the element does not contain any unsaved data.
     */
    public MongoBaseDao(DbProvider provider, Class<T> type, boolean fetchUpdatedElement) {
        this.provider = provider;
        this.type = type;
        this.fetchUpdatedElement = fetchUpdatedElement;
        DaoOptions daoOptions = provider.getDaoOptions();
        this.wildcardChar = (daoOptions == null) ? "*" : daoOptions.getWildcardChar();
    }

    protected Datastore ds() {
        return provider.getDb().getDatastore();
    }

    /**
     * converts the id to an objectId and calls {@code query(Object id)}.
     * @param element
     * @return
     */
    protected Query<T> query(T element){
        return query(element.get_id());
    }

    protected Query<T> query(Object id){
        return query().field("_id").equal(id);
    }

    protected Query<T> query() {
        return ds().createQuery(type);
    }

    /**
     *
     * @param element the element to be updated.
     * @param fields - a class that contains the fields that should be updated in element.
     *               This class does not have to inherit the element class.
     * @return the update operations to perform.
     * @throws MorphiaException if field does not have a getter or getter method is not public.
     */
    protected UpdateOperations<T> updateOperation(T element, Class fields) throws MorphiaException {
        UpdateOperations<T> operations = updateOperation();
        for(Field field : fields.getDeclaredFields()){
            String fieldName = field.getName();
            String getterName = "get"
                    + fieldName.substring(0,1).toUpperCase()
                    + fieldName.substring(1);
            String className = element.getClass().getName();
            try {
                addFieldToUpdateOperation(element, operations, fieldName, getterName);
            } catch (NoSuchMethodException e) {
                throw new MorphiaException(getterName + " method could not be found in class " + className);
            } catch (IllegalAccessException e) {
                throw new MorphiaException(getterName + " is not public in class " + className);
            } catch (InvocationTargetException e) {
                e.printStackTrace(); //simple getter should not be able to throw exception
            }
        }
        return operations;
    }

    protected UpdateOperations<T> updateOperation() {
        return ds().createUpdateOperations(type);
    }

    protected AggregationPipeline aggregation() {
        return ds().createAggregation(type);
    }

    @Override
    public long getCount(){
        return ds().getCount(type);
    }

    @Override
    public T create(T element) throws MorphiaException {
        ds().save(element);
        return element;
    }

    @Override
    public List<T> createMultiple(List<T> elements) throws MorphiaException {
        ds().save(elements);
        return elements;
    }

    @Override
    public abstract T update(I id, T element) throws MorphiaException;


    /**
     * Creates a partial update of element by updating
     * only fields that element class and fields have in common.
     * @param element
     * @param fields preferably a class generated by the {@Link PartialClass}
     * @return element
     * @throws MorphiaException
     */
    @Override
    public T update(I id, T element, Class fields) throws MorphiaException{
        Query<T> query = query(id);
        ds().update(query, updateOperation(element, fields));
        if(fetchUpdatedElement) return get(id);
        return element;
    }

    @Override
    public T updateAll(I id, T element) throws MorphiaException {
        return this.update(id, element, element.getClass());
    }

    private void addFieldToUpdateOperation(T element, UpdateOperations<T> operations, String fieldName, String getterName) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        Method getter = element.getClass().getMethod(getterName);
        Object value = getter.invoke(element);
        if(value == null){
            operations.unset(fieldName);
        }else{
            operations.set(fieldName, value);
        }
    }


//    @Override
//    public T updateAll(T element) throws MorphiaException {
//        if (element == null) {
//            throw new MorphiaException("element can not be null");
//        }
//        //this does not work when using the @Version annotation
//        //UpdateResults results = ds().updateFirst(query().field("_id").equal(element.get_id()), element, false);
//        /*if (!results.getUpdatedExisting()) {
//            throw new MorphiaException("element of type " + type.getName()
//                    + " and _id: " + element.get_id()
//                    + " does not exist");
//        }*/
//        ds().save(element);
//        return element;
//    }

    @Override
    public List<T> updateMultiple(List<T> elements, Class fields) throws MorphiaException {
        for(T element : elements){
            ds().update(element, updateOperation(element, fields));
        }
        if(fetchUpdatedElement) return multiGet(elements.stream().map(T::get_id).collect(Collectors.toList()));
        return elements;
    }

    @Override
    public List<T> updateMultiple(List<T> elements) throws MorphiaException {
        ds().save(elements);
        return elements;
    }

    @Override
    public T get(I id) throws MorphiaException, ValidationException {
        return ds().get(type, id);
    }

    @Override
    @SuppressWarnings("unchecked")
    public ListWithTotal<T> getByFieldsAnd(Map<String, String> fields, int page, int noPrPage, String orderBy, Order order) {
        Query query = query();

        for (Map.Entry<String, String> entry : fields.entrySet()) {
            String field = entry.getKey();
            String value = entry.getValue();
            boolean wildcardStart = value.startsWith(wildcardChar);
            boolean wildcardEnd = value.endsWith(wildcardChar);

            if (wildcardStart && wildcardEnd) {
                query.field(field).containsIgnoreCase(value);
            } else if (wildcardStart) {
                query.field(field).endsWithIgnoreCase(value);
            } else if (wildcardEnd) {
                query.field(field).startsWithIgnoreCase(value);
            } else {
                query.field(field).equalIgnoreCase(value);
            }
        }

        return getListWithTotal(page, noPrPage, orderBy, order, query);
    }

    @Override
    public ListWithTotal<T> getByFieldsOr(Map<String, String> fields, int page, int noPrPage, String orderBy, Order order, boolean wildcardSearch) {
        Query<T> query = query();

        Criteria[] criteria = new Criteria[fields.size()];
        if (wildcardSearch) {
            int i = 0;
            for (Map.Entry<String, String> entry : fields.entrySet()) {
                String field = entry.getKey();
                String value = entry.getValue();
                boolean wildcardStart = value.startsWith(wildcardChar);
                boolean wildcardEnd = value.endsWith(wildcardChar);
                value = value.replace(wildcardChar, "");

                if (wildcardStart && wildcardEnd) {
                    criteria[i] = query.criteria(field).containsIgnoreCase(value);
                } else if (wildcardStart) {
                    criteria[i] = query.criteria(field).endsWithIgnoreCase(value);
                } else if (wildcardEnd) {
                    criteria[i] = query.criteria(field).startsWithIgnoreCase(value);
                } else {
                    criteria[i] = query.criteria(field).equalIgnoreCase(value);
                }
                i++;
            }
        } else {
            int i = 0;
            for (Map.Entry<String, String> entry : fields.entrySet()) {
                criteria[i] = query.criteria(entry.getKey()).containsIgnoreCase(entry.getValue());
                i++;
            }
        }
        query.or(criteria);
        return getListWithTotal(page, noPrPage, orderBy, order, query);
    }

    private ListWithTotal<T> getListWithTotal(int page, int noPrPage, String orderBy, Order order, Query<T> query) {
        long count = query.count();
        List<T> elements = query
                .order(getOrder(orderBy, order))
                .asList(new FindOptions().limit(noPrPage).skip(page * noPrPage));
        return new ListWithTotal<>(elements, count);
    }

    @Override
    public List<T> multiGet(Collection<I> ids) throws MorphiaException, ValidationException {
        return ds().get(type, ids).asList();
    }

    @Override
    public List<T> getAll() throws MorphiaException {
        return query().asList();
    }

    @Override
    public ListWithTotal<T> getAllWithTotal(int page, int size, String orderBy, Order order) {
        Query<T> query = query();
        List<T> list = query
                .order(getOrder(orderBy, order))
                .asList(new FindOptions()
                        .skip(page*size)
                        .limit(size));
        return new ListWithTotal<>(list, query.count());
    }

    @Override
    public boolean delete(I id) throws MorphiaException, ValidationException {
        WriteResult result = ds().delete(type, id);
        return result.getN() > 0;
    }

    @Override
    public boolean deleteMultiple(List<I> ids) throws MorphiaException, ValidationException {
        WriteResult result = ds().delete(type, ids);
        return result.getN() > 0;
    }

    private Sort getOrder(String field, Order order){
        switch (order){
            case DESC:
                return Sort.descending(field);
            case ASC:
            default:
                return Sort.ascending(field);
        }
    }
}
